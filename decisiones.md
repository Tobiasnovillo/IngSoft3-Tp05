# üß† decisiones.md ‚Äî Trabajo Pr√°ctico 05 ‚Äì DevOps CI/CD Pipelines (MiniShop)

## üìã Contexto general
El proyecto **MiniShop** es una aplicaci√≥n web completa (Full Stack) desarrollada con:
- **Frontend:** React (Node 20)
- **Backend:** Express.js + SQLite
- **Infraestructura:** Azure Web Apps (Linux)
- **CI/CD:** Azure DevOps Pipelines (YAML)

El objetivo del trabajo fue implementar un **pipeline CI/CD completo**, con **stages de Build, QA y Producci√≥n**, automatizando el despliegue, validaciones y manejo de entornos.

---

## ‚öôÔ∏è Arquitectura general de CI/CD

El pipeline se ejecuta autom√°ticamente al hacer *push* en la rama `main`.  
Est√° compuesto por **3 stages principales**:

1. **Build:**  
   - Instala dependencias.  
   - Construye el frontend React.  
   - Empaqueta el backend (`server.zip`) y el frontend (`client.zip`).  
   - Publica los artefactos.

2. **QA (Testing):**  
   - Despliega los artefactos al entorno **myshop1qaapi / myshop1**.  
   - Usa variables del grupo `minishop-qa`.  
   - Ejecuta health checks para validar que el backend y frontend respondan correctamente.

3. **PROD (Producci√≥n):**  
   - Requiere aprobaci√≥n manual antes del despliegue.  
   - Despliega en **myshop1apiprod / myshop1prod**.  
   - Usa variables del grupo `minishop-prod`.  
   - Verifica nuevamente la salud de los servicios post-deploy.

---

## üîí Variables y Secrets

Las **variables** permiten configurar cada entorno de forma independiente (QA y PROD).  
Se gestionaron en **Azure DevOps Variable Groups**.

| Variable | Entorno QA | Entorno PROD | Descripci√≥n |
|-----------|-------------|--------------|--------------|
| `AZURE_WEBAPP_API_NAME` | `myshop1qaapi` | `myshop1apiprod` | Nombre del backend App Service |
| `AZURE_WEBAPP_FRONT_NAME` | `myshop1` | `myshop1prod` | Nombre del frontend App Service |
| `DATA_DIR` | `/home/site/wwwroot/data` | `/home/site/wwwroot/data` | Carpeta donde se guarda la base SQLite |
| `DB_PATH` | `/home/site/wwwroot/data/qa.sqlite` | `/home/site/wwwroot/data/prod.sqlite` | Ruta f√≠sica de la base SQLite |
| `NODE_ENV` | `production` | `production` | Entorno de ejecuci√≥n Node.js |

---

### üß≠ ¬øQu√© son los *Secrets*?

Los **Secrets** (o ‚Äúsecretos‚Äù) son variables sensibles que se ocultan para proteger informaci√≥n confidencial.  
Ejemplos:
- Credenciales o tokens de conexi√≥n a Azure (`AZURE_CREDENTIALS`)
- Claves API o contrase√±as
- Strings de conexi√≥n a bases externas o storage

> En Azure DevOps, los secrets se almacenan encriptados y no se muestran en los logs.  
> Se inyectan como variables de entorno en tiempo de ejecuci√≥n.

---

## üîÅ ¬øQu√© es un Pipeline?

Un **Pipeline** es una secuencia automatizada de pasos que definen c√≥mo se construye, prueba y despliega una aplicaci√≥n.

- **CI (Continuous Integration):** Automatiza la integraci√≥n y compilaci√≥n del c√≥digo al hacer commits.
- **CD (Continuous Delivery/Deployment):** Automatiza el despliegue del c√≥digo en entornos como QA o Producci√≥n.

En este proyecto, el pipeline est√° definido con **YAML** (`azure-pipelines.yml`), con stages y jobs diferenciados.

---

## üöÄ ¬øQu√© es un Release Pipeline?

Un **Release Pipeline** toma los artefactos generados por el *Build Pipeline* y los despliega en distintos entornos.  
Permite:

- Definir variables por entorno (QA/PROD).  
- Requerir aprobaciones manuales antes de pasar a producci√≥n.  
- Realizar *health checks* post-deploy para validar el √©xito del despliegue.

> En este trabajo, el release pipeline est√° integrado dentro del mismo YAML, con gates, health checks y aprobaci√≥n manual entre QA y PROD.

---

## üí° Decisiones t√©cnicas tomadas

| Decisi√≥n | Justificaci√≥n |
|-----------|----------------|
| Separar los entornos QA y PROD en distintos App Services | Evitar que compartan el mismo filesystem y base SQLite. |
| Mantener SQLite local en `/home/site/wwwroot/data` | Permitir persistencia simple sin base externa, cumpliendo el alcance del TP. |
| Asignar nombres distintos a las bases (`qa.sqlite`, `prod.sqlite`) | Aislar completamente los datos entre QA y Producci√≥n. |
| Configurar CORS con or√≠genes permitidos (`myshop1` y `myshop1prod`) | Evitar errores de acceso cruzado entre frontend y backend. |
| A√±adir logs de diagn√≥stico (paths, entorno activo) | Facilitar verificaci√≥n en Log Stream de Azure. |
| Implementar health checks autom√°ticos (`/health`) | Validar que los servicios est√©n activos antes de aprobar el despliegue. |
| Usar `includeRootFolder: false` en `ArchiveFiles@2` | Evitar subcarpetas en los artefactos (`server/server` o `client/build`). |
| Reiniciar App Services luego del deploy | Asegurar que se use la √∫ltima versi√≥n publicada. |
| Configurar aprobaci√≥n manual entre QA ‚Üí PROD | Cumplir el requisito de control de cambios y revisi√≥n antes de producci√≥n. |
| Manejar SQLite por sitio (`WEBSITE_SITE_NAME`) | Generar autom√°ticamente una base distinta por entorno. |

---

## üß± Estructura de despliegue final

| Entorno | API Backend | Frontend | Base de datos | App Service Plan |
|----------|--------------|-----------|----------------|------------------|
| QA | `myshop1qaapi.azurewebsites.net` | `myshop1.azurewebsites.net` | `/home/site/wwwroot/data/qa.sqlite` | `myshop-plan` |
| PROD | `myshop1apiprod.azurewebsites.net` | `myshop1prod.azurewebsites.net` | `/home/site/wwwroot/data/prod.sqlite` | `myshop-prod-plan` |

---

## ü©∫ Health checks configurados

Durante cada etapa de despliegue, se valida que el backend est√© activo con el siguiente comando:

```bash
curl -s -o /dev/null -w "%{http_code}" "https://<backend>/health"


Si devuelve 200, el deploy se marca como exitoso.
Si falla m√°s de 3 veces consecutivas, el job se detiene autom√°ticamente.



## Endpoints de verificaci√≥n:

QA ‚Üí https://myshop1qaapi.azurewebsites.net/health

PROD ‚Üí https://myshop1apiprod.azurewebsites.net/health

---

# Decisiones T√©cnicas - Testing (TP06)

## üéØ Estrategia de Testing

### Frameworks Elegidos

1. **Backend Testing:**
   - Jest: Framework principal de testing
   - Supertest: Para testing de endpoints HTTP
   - SQLite en memoria: Para tests de base de datos aislados

2. **Frontend Testing:**
   - Jest: Framework base
   - React Testing Library: Para testing de componentes React
   - jest-dom: Para assertions espec√≠ficas del DOM
   - user-event: Para simular interacciones de usuario

### Estrategia de Mocking

1. **Backend:**
   - Base de datos: Usando SQLite en memoria para tests
   - Variables de entorno: Mockeadas para simular distintos entornos
   - Servicios externos: Aislados mediante mocks cuando sea necesario

2. **Frontend:**
   - Llamadas API: Mockeadas usando jest.mock para axios
   - Respuestas del servidor: Simuladas para distintos escenarios
   - Eventos del usuario: Simulados con @testing-library/user-event

## üìù Casos de Prueba Relevantes

### Backend Tests

1. **API Endpoints:**
   - GET /health: Verifica el estado del servicio
   - CRUD Productos: Prueba todas las operaciones b√°sicas
   - Manejo de errores: Valida respuestas para casos inv√°lidos

2. **Validaciones:**
   - Campos requeridos en productos
   - Formatos de datos correctos
   - Manejo de IDs inexistentes

### Frontend Tests

1. **Componentes React:**
   - Renderizado inicial
   - Manejo del estado de carga
   - Visualizaci√≥n de productos
   - Formularios de creaci√≥n/edici√≥n

2. **Interacciones de Usuario:**
   - Agregar producto
   - Editar producto existente
   - Eliminar producto
   - Manejo de errores en formularios

## üîÑ Integraci√≥n con CI/CD

1. **Pipeline Stage de Testing:**
   - Ejecuci√≥n de tests backend
   - Ejecuci√≥n de tests frontend
   - Generaci√≥n de reportes de cobertura
   - Publicaci√≥n de resultados en Azure DevOps

2. **Pol√≠ticas de Branch:**
   - Tests deben pasar antes de merge
   - Cobertura m√≠nima requerida
   - Health checks en ambos entornos

## üìä Evidencias de Ejecuci√≥n

### Comandos de Ejecuci√≥n Local

```bash
# Backend Tests
cd server
npm test

# Frontend Tests
cd client
npm test
```

### Cobertura de C√≥digo

- Backend: Tests cubren rutas API, validaciones y manejo de errores
- Frontend: Tests cubren componentes principales y l√≥gica de negocio
- Reportes disponibles en Azure DevOps despu√©s de cada build



# TP06 ‚Äì DevOps CI/CD + Testing Automation  
**Integrantes:** Salvador Novillo Saravia, Santos Romero Reyna, Tobias Novillo Saravia  
**Materia:** Ingenier√≠a de Software III  
**A√±o:** 2025  

---

## üß± 1. Stack Tecnol√≥gico

| Capa | Tecnolog√≠a | Descripci√≥n |
|------|-------------|--------------|
| **Frontend** | React + Vite | Interfaz de usuario con integraci√≥n a API REST |
| **Backend** | Node.js + Express + SQLite3 | Servicio RESTful para gesti√≥n de productos |
| **CI/CD** | Azure DevOps (Pipelines YAML + Releases Classic) | Pipeline automatizado de build, test y despliegue |
| **Infraestructura** | Azure Web Apps (Linux) | Hospedaje en QA y Producci√≥n |
| **Control de versiones** | GitHub | Repositorio principal conectado a Azure DevOps |

---

## üß© 2. Frameworks de Testing y Justificaci√≥n

| Capa | Framework | Motivo |
|------|------------|--------|
| **Backend** | Jest + Supertest | Permite testear endpoints Express sin necesidad de levantar manualmente el servidor. Se integra bien con SQLite y soporta mocks. |
| **Frontend** | Jest + React Testing Library | Facilita testear componentes React de forma declarativa y centrada en el usuario. Emula el DOM con `jsdom`. |

Los tests se ejecutan tanto **localmente** como **autom√°ticamente en el pipeline**.

---

## üß† 3. Estrategia de Mocking

| Componente | Estrategia | Ejemplo |
|-------------|-------------|----------|
| **Backend (Servicio de Productos)** | Mock de base de datos SQLite mediante `jest.fn()` | Se reemplaza `db.all()` por una funci√≥n simulada que retorna productos fijos. |
| **Frontend (API Fetch)** | Mock global de `fetch` | En `api.test.js`, se define `global.fetch = jest.fn()` para interceptar llamadas y retornar respuestas JSON simuladas. |

> üéØ Con esto, los tests son **deterministas** y no dependen de conexi√≥n ni base de datos real.

---

## üß™ 4. Casos de Prueba Relevantes

### üîπ Backend (`products.controller.test.js`)
- **GET /api/products** ‚Üí verifica c√≥digo 200 y contenido JSON.
- **GET /api/products/:id** ‚Üí devuelve producto correcto o 404 si no existe.

### üîπ Frontend (`ProductList.test.jsx`)
- Renderiza `<ProductList />` con mock de API.
- Usa `waitFor` para esperar la carga de productos.
- Valida que aparezcan elementos con `expect(screen.getByText(...))`.

---

## ‚öôÔ∏è 5. Ejecuci√≥n Autom√°tica de Tests (CI/CD)

Los tests se integraron en la etapa **Build** del pipeline YAML (`azure-pipelines.yml`):

```yaml
- script: |
    echo "üß™ Ejecutando pruebas backend..."
    cd server
    npm ci
    npm test -- --coverage --ci --reporters=jest-junit
    cd ..

    echo "üß™ Ejecutando pruebas frontend..."
    cd client
    npm ci
    npm test -- --coverage --ci --reporters=jest-junit
    cd ..
  displayName: "Run automated tests"



# üó£Ô∏è Defensa Oral ‚Äì TP06 (Testing + DevOps)

## üéØ Preguntas sobre Testing y Automatizaci√≥n

### üß© ¬øPor qu√© elegiste estos frameworks de testing para tu stack tecnol√≥gico?
Eleg√≠ **Jest** y **React Testing Library** para el frontend porque son los frameworks m√°s estandarizados para aplicaciones React.  
- Jest permite ejecutar tests de forma r√°pida, con un entorno de `jsdom` que simula el navegador.  
- React Testing Library se centra en probar la aplicaci√≥n desde la perspectiva del usuario, lo que ayuda a validar la funcionalidad real y no solo la implementaci√≥n.  

En el backend, us√© **Jest** junto con **Supertest** porque facilita testear endpoints de Express sin levantar manualmente el servidor, lo que hace que las pruebas sean m√°s ligeras y repetibles.  
Ambos frameworks se integran f√°cilmente en pipelines CI/CD, lo que permiti√≥ automatizar los tests sin configuraciones adicionales.

---

### üß† ¬øC√≥mo decidiste qu√© componentes mockear y cu√°les probar con implementaciones reales?
Mocke√© todos los componentes **externos o con dependencias cambiantes**:
- En el backend: la base de datos SQLite fue mockeada para evitar escribir/leer datos reales y lograr que las pruebas sean deterministas.  
- En el frontend: se mocke√≥ la funci√≥n `fetch` para simular respuestas de la API sin depender del backend real.  

Sin embargo, **no se mockean funciones de l√≥gica interna** (por ejemplo, controladores o componentes puros) porque el objetivo es validar que esas funciones procesen los datos correctamente.

En resumen, mockeo las **entradas/salidas externas**, pero pruebo la **l√≥gica de negocio real**.

---

### üîç ¬øC√≥mo valid√°s que tus tests realmente est√°n probando la l√≥gica correcta?
1. **Cobertura de c√≥digo:** ejecuto los tests con `--coverage` para verificar que las funciones y ramas principales est√©n cubiertas.  
2. **Aserciones espec√≠ficas:** cada test incluye comprobaciones concretas (`expect`) sobre el estado final, no solo sobre la existencia de un elemento.  
3. **Pruebas de error:** agregu√© casos negativos (por ejemplo, respuesta 404 o errores de red) para validar el manejo de excepciones.  
4. **Mock controlado:** cuando mockeo datos, me aseguro de que los resultados esperados dependan directamente de la funci√≥n bajo prueba y no del mock.

Esto garantiza que los tests no pasen ‚Äúpor casualidad‚Äù y reflejen el comportamiento real del sistema.

---

### ‚öôÔ∏è ¬øC√≥mo manej√°s los tests que dependen de estado o datos externos?
Los tests que dependen de estado (por ejemplo, consultas a la base de datos o llamadas a una API) se **aislan completamente**:
- Uso `beforeEach()` y `afterEach()` para limpiar mocks y restaurar el estado inicial.  
- Se mockean respuestas externas (API o DB) con datos consistentes.  
- Si un test requiere un entorno espec√≠fico (por ejemplo, usuario autenticado), se simula con fixtures o datos de ejemplo.

Esto asegura que cada test sea independiente y no afecte a otros ‚Äî uno puede fallar sin romper el resto del pipeline.

---

# üß∞ Defensa Oral ‚Äì TP05 (DevOps, CI/CD y Azure)

## ‚òÅÔ∏è ¬øPor qu√© elegiste esta herramienta de CI/CD para este escenario?
Eleg√≠ **Azure DevOps Pipelines** porque:
- Se integra directamente con **Azure Web Apps**, facilitando despliegues autom√°ticos sin configuraci√≥n adicional.  
- Permite definir pipelines en YAML (para CI) y pipelines visuales (para Release), combinando automatizaci√≥n y control manual.  
- Tiene gesti√≥n nativa de **Variables Groups**, **Service Connections** y **aprobaciones de Release**, todo dentro del mismo ecosistema.

Adem√°s, es ideal para un entorno acad√©mico con recursos gratuitos y despliegues r√°pidos.

---

## üîí ¬øC√≥mo gestion√°s variables sensibles entre entornos?
Las variables se centralizan en **Variable Groups**:
- `minishop-qa` y `minishop-prod` contienen credenciales, URLs y nombres de Web Apps.
- Los valores cr√≠ticos (`azureSubscription`, `DB_CONN_STRING`, `REACT_APP_API_BASE_URL`) est√°n marcados como **secrets**.
- El YAML no contiene credenciales directas; solo referencias como `$(REACT_APP_API_BASE_URL)`.

Esto mantiene el c√≥digo seguro y permite modificar configuraciones sin alterar el repositorio.

---

## ‚úÖ ¬øQu√© criterios us√°s para aprobar un pase a Producci√≥n?
1. **Tests autom√°ticos aprobados** en la etapa Build.  
2. **Despliegue QA exitoso** y verificado visualmente (sin errores HTTP 5xx).  
3. **Integraci√≥n completa** entre frontend y backend QA.  
4. **Revisi√≥n manual del equipo o docente** antes del Release.  

Solo si las tres primeras condiciones se cumplen, se aprueba manualmente el pase a Producci√≥n desde el pipeline Release.

---

## üöÄ ¬øC√≥mo valid√°s que un despliegue fue exitoso?
- Reviso el log del **Azure Pipeline** para confirmar que el task `AzureWebApp@1` finaliz√≥ con c√≥digo `0`.
- Accedo a la URL desplegada (`myshop1qa.azurewebsites.net` o `myshop1prod.azurewebsites.net`) y verifico la respuesta del frontend y del endpoint `/api/products`.
- Tambi√©n puedo usar la pesta√±a **‚ÄúLogs ‚Üí Deployment Center‚Äù** en Azure Portal para corroborar que los archivos fueron publicados correctamente.

---

## üîÅ ¬øC√≥mo ejecut√°s un rollback y en qu√© situaciones?
El rollback se realiza desde **Azure Portal ‚Üí Web App ‚Üí Deployment Center ‚Üí History**:
- Selecciono una versi√≥n anterior del despliegue (QA o PROD).
- Hago clic en ‚ÄúRedeploy‚Äù para volver al estado anterior.

Se ejecuta un rollback si:
1. La app deja de responder o lanza errores 500 tras un deploy.  
2. Los tests post-despliegue fallan.  
3. Se detecta una regresi√≥n funcional en producci√≥n.

Gracias a los artefactos `server.zip` y `client-prod.zip` guardados por el pipeline, puedo revertir a una versi√≥n estable r√°pidamente.

---

## üß© Conclusi√≥n general de ambas defensas

El flujo completo **TP05 + TP06**
